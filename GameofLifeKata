from collections import deque

def get_generation(cells, generations):
    if generations > 0:
        # pad the cells
        rows = len(cells)
        cols = len(cells[0])

        zeros = [0] * (cols+2)

        # output array
        output_array = []


        # pad the top fo the board
        cells_padded = []
        cells_padded.append(zeros)

        # pad the rows so we have an 8 adjeceny on all
        for row in cells:
            row_padded = []
            row_padded.append(0)
            for item in row:
                row_padded.append(item) # append right element
            row_padded.append(0)
            cells_padded.append(row_padded)

        # pad bottom of the board too
        cells_padded.append(zeros)

        # do the middle
        for i in range(0,rows+2,1):
            row = []
            for j in range(0,cols+2,1):
                
                #row above
                if i == 0:
                    cells_above = 0
                elif j == 0:
                    cells_above =cells_padded[i-1][j]+cells_padded[i-1][j+1]
                elif j == cols+1:
                    cells_above = cells_padded[i-1][j-1]+cells_padded[i-1][j]
                else:
                    cells_above = cells_padded[i-1][j-1]+cells_padded[i-1][j]+cells_padded[i-1][j+1]    # add row above
                
                # row equal
                if j == 0:
                    cells_mid = cells_padded[i][j+1]
                elif j == cols+1:
                    cells_mid = cells_padded[i][j-1]
                else:
                    cells_mid = cells_padded[i][j-1]+cells_padded[i][j+1]
                
                # rows below
                if i == rows+1:
                    cells_below = 0
                elif j == 0:
                    cells_below = cells_padded[i+1][j]+cells_padded[i+1][j+1]
                elif j == cols+1:
                    cells_below = cells_padded[i+1][j-1]+cells_padded[i+1][j]
                else:
                    cells_below = cells_padded[i+1][j-1]+cells_padded[i+1][j]+cells_padded[i+1][j+1]
                    
                    
                
                alive_cells = cells_above + cells_mid + cells_below


                #get the cell status based on alive neighbours and current status
                # shifted -1 in row and column to compensate for padding
                row.append(cell_status(alive_cells,cells_padded[i][j]))
            output_array.append(row)
        
        # trim the lists (array) to exclude empty rows and columns
        
        
        generations -=1

    
        if generations >= 1:
            output_array = get_generation(output_array,generations)
        
        output_array = trim_array(output_array)
        return output_array
    else:
        return cells

# function for determining the status of the cell (alive or dead)
def cell_status(alive_cells,current_status):
    if alive_cells == 3:
        return 1
    elif alive_cells == 2:
        return current_status
    elif alive_cells < 2 or alive_cells > 3:
        return 0
    else:
        return 0

def trim_array(output_lst):
    first_row_sum = 0
    last_row_sum = 0
    first_col_sum = 0
    last_col_sum = 0
    
    while first_row_sum == 0 or last_row_sum == 0 or first_col_sum == 0 or last_col_sum == 0:
        # see what need trimming
        first_row_sum = sum(output_lst[0][:])
        last_row_sum = sum(output_lst[len(output_lst)-1][:])
        first_col_sum = sum(output_lst[:][0])
        last_col_sum = sum(output_lst[:][len(output_lst)-1])

        #trims the array
        if first_row_sum == 0:
            output_lst = output_lst[1:]
        if last_row_sum == 0:
            output_lst = output_lst[:-1]
        if first_col_sum == 0:
            for row in output_lst:
                del row[0]
        if last_col_sum == 0:
            for row in output_lst:
                del row[len(row)-1]
                print(output_lst)
        
    return output_lst
    
    